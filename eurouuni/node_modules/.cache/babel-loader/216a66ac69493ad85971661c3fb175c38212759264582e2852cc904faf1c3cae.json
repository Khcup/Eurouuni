{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseGetAllArguments = exports.Transaction = void 0;\nconst backoff_1 = require(\"./backoff\");\nconst index_1 = require(\"./index\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst document_reader_1 = require(\"./document-reader\");\n/*!\n * Error message for transactional reads that were executed after performing\n * writes.\n */\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\nconst READ_ONLY_WRITE_ERROR_MSG = 'Firestore read-only transactions cannot execute writes.';\n/**\n * A reference to a transaction.\n *\n * The Transaction object passed to a transaction's updateFunction provides\n * the methods to read and write data within the transaction context. See\n * [runTransaction()]{@link Firestore#runTransaction}.\n *\n * @class Transaction\n */\nclass Transaction {\n  /**\n   * @private\n   *\n   * @param firestore The Firestore Database client.\n   * @param requestTag A unique client-assigned identifier for the scope of\n   * this transaction.\n   * @param transactionOptions The user-defined options for this transaction.\n   */\n  constructor(firestore, requestTag, transactionOptions) {\n    this._readOnly = false;\n    this._maxAttempts = index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;\n    this._firestore = firestore;\n    this._writeBatch = firestore.batch();\n    this._requestTag = requestTag;\n    this._backoff = new backoff_1.ExponentialBackoff();\n    if (transactionOptions) {\n      if (transactionOptions.readOnly) {\n        this._readOnly = true;\n        this._maxAttempts = 1;\n        this._readTime = transactionOptions.readTime;\n      } else {\n        this._maxAttempts = transactionOptions.maxAttempts || index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;\n      }\n    }\n  }\n  /**\n   * Retrieve a document or a query result from the database. Holds a\n   * pessimistic lock on all returned documents.\n   *\n   * @param {DocumentReference|Query} refOrQuery The document or query to\n   * return.\n   * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\n   * QuerySnapshot for the returned documents.\n   *\n   * @example\n   * ```\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   return transaction.get(documentRef).then(doc => {\n   *     if (doc.exists) {\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n   *     } else {\n   *       transaction.create(documentRef, { count: 1 });\n   *     }\n   *   });\n   * });\n   * ```\n   */\n  get(refOrQuery) {\n    if (!this._writeBatch.isEmpty) {\n      throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n    }\n    if (refOrQuery instanceof reference_1.DocumentReference) {\n      const documentReader = new document_reader_1.DocumentReader(this._firestore, [refOrQuery]);\n      documentReader.transactionId = this._transactionId;\n      documentReader.readTime = this._readTime;\n      return documentReader.get(this._requestTag).then(([res]) => res);\n    }\n    if (refOrQuery instanceof reference_1.Query) {\n      return refOrQuery._get(this._transactionId || this._readTime);\n    }\n    if (refOrQuery instanceof reference_1.AggregateQuery) {\n      return refOrQuery._get(this._transactionId || this._readTime);\n    }\n    throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference, Query, or AggregateQuery.');\n  }\n  /**\n   * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\n   * all returned documents.\n   *\n   * The first argument is required and must be of type `DocumentReference`\n   * followed by any additional `DocumentReference` documents. If used, the\n   * optional `ReadOptions` must be the last argument.\n   *\n   * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\n   * `DocumentReferences` to receive, followed by an optional field mask.\n   * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n   * contains an array with the resulting document snapshots.\n   *\n   * @example\n   * ```\n   * let firstDoc = firestore.doc('col/doc1');\n   * let secondDoc = firestore.doc('col/doc2');\n   * let resultDoc = firestore.doc('col/doc3');\n   *\n   * firestore.runTransaction(transaction => {\n   *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\n   *     transaction.set(resultDoc, {\n   *       sum: docs[0].get('count') + docs[1].get('count')\n   *     });\n   *   });\n   * });\n   * ```\n   */\n  getAll(...documentRefsOrReadOptions) {\n    if (!this._writeBatch.isEmpty) {\n      throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n    }\n    (0, validate_1.validateMinNumberOfArguments)('Transaction.getAll', documentRefsOrReadOptions, 1);\n    const {\n      documents,\n      fieldMask\n    } = parseGetAllArguments(documentRefsOrReadOptions);\n    const documentReader = new document_reader_1.DocumentReader(this._firestore, documents);\n    documentReader.fieldMask = fieldMask || undefined;\n    documentReader.transactionId = this._transactionId;\n    documentReader.readTime = this._readTime;\n    return documentReader.get(this._requestTag);\n  }\n  /**\n   * Create the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. The operation will\n   * fail the transaction if a document exists at the specified location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {DocumentData} data The object data to serialize as the document.\n   * @returns {Transaction} This Transaction instance. Used for\n   * chaining method calls.\n   *\n   * @example\n   * ```\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   return transaction.get(documentRef).then(doc => {\n   *     if (!doc.exists) {\n   *       transaction.create(documentRef, { foo: 'bar' });\n   *     }\n   *   });\n   * });\n   * ```\n   */\n  create(documentRef, data) {\n    if (this._readOnly) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    this._writeBatch.create(documentRef, data);\n    return this;\n  }\n  /**\n   * Writes to the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document\n   * does not exist yet, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into the\n   * existing document.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * set.\n   * @param {T|Partial<T>} data The object to serialize as the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge - If true, set() merges the values\n   * specified in its data argument. Fields omitted from this set() call remain\n   * untouched. If your input sets any field to an empty map, all nested fields\n   * are overwritten.\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched. If your input sets any field to\n   * an empty map, all nested fields are overwritten.\n   * @throws {Error} If the provided input is not a valid Firestore document.\n   * @returns {Transaction} This Transaction instance. Used for\n   * chaining method calls.\n   *\n   * @example\n   * ```\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   transaction.set(documentRef, { foo: 'bar' });\n   *   return Promise.resolve();\n   * });\n   * ```\n   */\n  set(documentRef, data, options) {\n    if (this._readOnly) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    if (options) {\n      this._writeBatch.set(documentRef, data, options);\n    } else {\n      this._writeBatch.set(documentRef, data);\n    }\n    return this;\n  }\n  /**\n   * Updates fields in the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. The update will\n   * fail if applied to a document that does not exist.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values. Nested fields can be\n   * updated by providing dot-separated field path strings or by providing\n   * FieldPath objects.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * updated.\n   * @param {UpdateData|string|FieldPath} dataOrField An object\n   * containing the fields and values with which to update the document\n   * or the path of the first field to update.\n   * @param {\n   * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n   * An alternating list of field paths and values to update or a Precondition\n   * to to enforce on this update.\n   * @throws {Error} If the provided input is not valid Firestore data.\n   * @returns {Transaction} This Transaction instance. Used for\n   * chaining method calls.\n   *\n   * @example\n   * ```\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   return transaction.get(documentRef).then(doc => {\n   *     if (doc.exists) {\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n   *     } else {\n   *       transaction.create(documentRef, { count: 1 });\n   *     }\n   *   });\n   * });\n   * ```\n   */\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    if (this._readOnly) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    // eslint-disable-next-line prefer-rest-params\n    (0, validate_1.validateMinNumberOfArguments)('Transaction.update', arguments, 2);\n    this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n    return this;\n  }\n  /**\n   * Deletes the document referred to by the provided [DocumentReference]\n   * {@link DocumentReference}.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * deleted.\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the transaction if the\n   * document doesn't exist or was last updated at a different time.\n   * @param {boolean=} precondition.exists If set, enforces that the target\n   * document must or must not exist.\n   * @returns {Transaction} This Transaction instance. Used for\n   * chaining method calls.\n   *\n   * @example\n   * ```\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   transaction.delete(documentRef);\n   *   return Promise.resolve();\n   * });\n   * ```\n   */\n  delete(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  documentRef, precondition) {\n    if (this._readTime) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    this._writeBatch.delete(documentRef, precondition);\n    return this;\n  }\n  /**\n   * Starts a transaction and obtains the transaction id from the server.\n   *\n   * @private\n   * @internal\n   */\n  async begin() {\n    const request = {\n      database: this._firestore.formattedName\n    };\n    if (this._readOnly) {\n      request.options = {\n        readOnly: {}\n      };\n    } else if (this._transactionId) {\n      request.options = {\n        readWrite: {\n          retryTransaction: this._transactionId\n        }\n      };\n    }\n    const resp = await this._firestore.request('beginTransaction', request, this._requestTag);\n    this._transactionId = resp.transaction;\n  }\n  /**\n   * Commits all queued-up changes in this transaction and releases all locks.\n   *\n   * @private\n   * @internal\n   */\n  async commit() {\n    if (this._readTime) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    await this._writeBatch._commit({\n      transactionId: this._transactionId,\n      requestTag: this._requestTag\n    });\n  }\n  /**\n   * Releases all locks and rolls back this transaction.\n   *\n   * @private\n   * @internal\n   */\n  async rollback() {\n    if (!this._transactionId) {\n      return;\n    }\n    const request = {\n      database: this._firestore.formattedName,\n      transaction: this._transactionId\n    };\n    try {\n      await this._firestore.request('rollback', request, this._requestTag);\n    } catch (reason) {\n      (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Best effort to rollback failed with error:', reason);\n    }\n  }\n  /**\n   * Executes `updateFunction()` and commits the transaction with retry.\n   *\n   * @private\n   * @internal\n   * @param updateFunction The user function to execute within the transaction\n   * context.\n   */\n  async runTransaction(updateFunction) {\n    if (this._maxAttempts === 1) {\n      return this.runTransactionOnce(updateFunction);\n    }\n    let lastError = undefined;\n    for (let attempt = 0; attempt < this._maxAttempts; ++attempt) {\n      try {\n        if (lastError) {\n          (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);\n        }\n        this._writeBatch._reset();\n        await this.maybeBackoff(lastError);\n        return await this.runTransactionOnce(updateFunction);\n      } catch (err) {\n        lastError = err;\n        if (!this._transactionId || !isRetryableTransactionError(err)) {\n          break;\n        }\n      }\n    }\n    (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\n    return Promise.reject(lastError);\n  }\n  /**\n   * Make single attempt to execute `updateFunction()` and commit the\n   * transaction. Will rollback upon error.\n   *\n   * @private\n   * @internal\n   * @param updateFunction The user function to execute within the transaction\n   * context.\n   */\n  async runTransactionOnce(updateFunction) {\n    if (!this._readTime) {\n      await this.begin();\n    }\n    try {\n      const promise = updateFunction(this);\n      if (!(promise instanceof Promise)) {\n        throw new Error('You must return a Promise in your transaction()-callback.');\n      }\n      const result = await promise;\n      if (!this._readTime) {\n        await this.commit();\n      }\n      return result;\n    } catch (err) {\n      (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);\n      await this.rollback();\n      return Promise.reject(err);\n    }\n  }\n  /**\n   * Delays further operations based on the provided error.\n   *\n   * @private\n   * @internal\n   * @return A Promise that resolves after the delay expired.\n   */\n  async maybeBackoff(error) {\n    if ((error === null || error === void 0 ? void 0 : error.code) === 8 /* StatusCode.RESOURCE_EXHAUSTED */) {\n      this._backoff.resetToMax();\n    }\n    await this._backoff.backoffAndWait();\n  }\n}\nexports.Transaction = Transaction;\n/**\n * Parses the arguments for the `getAll()` call supported by both the Firestore\n * and Transaction class.\n *\n * @private\n * @internal\n * @param documentRefsOrReadOptions An array of document references followed by\n * an optional ReadOptions object.\n */\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n  let documents;\n  let readOptions = undefined;\n  if (Array.isArray(documentRefsOrReadOptions[0])) {\n    throw new Error('getAll() no longer accepts an array as its first argument. ' + 'Please unpack your array and call getAll() with individual arguments.');\n  }\n  if (documentRefsOrReadOptions.length > 0 && (0, util_1.isPlainObject)(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n    readOptions = documentRefsOrReadOptions.pop();\n    documents = documentRefsOrReadOptions;\n  } else {\n    documents = documentRefsOrReadOptions;\n  }\n  for (let i = 0; i < documents.length; ++i) {\n    (0, reference_1.validateDocumentReference)(i, documents[i]);\n  }\n  validateReadOptions('options', readOptions, {\n    optional: true\n  });\n  const fieldMask = readOptions && readOptions.fieldMask ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath)) : null;\n  return {\n    fieldMask,\n    documents\n  };\n}\nexports.parseGetAllArguments = parseGetAllArguments;\n/**\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\n * is an array of strings or field paths.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the ReadOptions can be omitted.\n */\nfunction validateReadOptions(arg, value, options) {\n  if (!(0, validate_1.validateOptional)(value, options)) {\n    if (!(0, util_1.isObject)(value)) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} Input is not an object.'`);\n    }\n    const options = value;\n    if (options.fieldMask !== undefined) {\n      if (!Array.isArray(options.fieldMask)) {\n        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} \"fieldMask\" is not an array.`);\n      }\n      for (let i = 0; i < options.fieldMask.length; ++i) {\n        try {\n          (0, path_1.validateFieldPath)(i, options.fieldMask[i]);\n        } catch (err) {\n          throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\n        }\n      }\n    }\n  }\n}\nfunction isRetryableTransactionError(error) {\n  if (error.code !== undefined) {\n    // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\n    switch (error.code) {\n      case 10 /* StatusCode.ABORTED */:\n      case 1 /* StatusCode.CANCELLED */:\n      case 2 /* StatusCode.UNKNOWN */:\n      case 4 /* StatusCode.DEADLINE_EXCEEDED */:\n      case 13 /* StatusCode.INTERNAL */:\n      case 14 /* StatusCode.UNAVAILABLE */:\n      case 16 /* StatusCode.UNAUTHENTICATED */:\n      case 8 /* StatusCode.RESOURCE_EXHAUSTED */:\n        return true;\n      case 3 /* StatusCode.INVALID_ARGUMENT */:\n        // The Firestore backend uses \"INVALID_ARGUMENT\" for transactions\n        // IDs that have expired. While INVALID_ARGUMENT is generally not\n        // retryable, we retry this specific case.\n        return !!error.message.match(/transaction has expired/);\n      default:\n        return false;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","parseGetAllArguments","Transaction","backoff_1","require","index_1","logger_1","path_1","reference_1","util_1","validate_1","document_reader_1","READ_AFTER_WRITE_ERROR_MSG","READ_ONLY_WRITE_ERROR_MSG","constructor","firestore","requestTag","transactionOptions","_readOnly","_maxAttempts","DEFAULT_MAX_TRANSACTION_ATTEMPTS","_firestore","_writeBatch","batch","_requestTag","_backoff","ExponentialBackoff","readOnly","_readTime","readTime","maxAttempts","get","refOrQuery","isEmpty","Error","DocumentReference","documentReader","DocumentReader","transactionId","_transactionId","then","res","Query","_get","AggregateQuery","getAll","documentRefsOrReadOptions","validateMinNumberOfArguments","documents","fieldMask","undefined","create","documentRef","data","set","options","update","dataOrField","preconditionOrValues","arguments","delete","precondition","begin","request","database","formattedName","readWrite","retryTransaction","resp","transaction","commit","_commit","rollback","reason","logger","runTransaction","updateFunction","runTransactionOnce","lastError","attempt","_reset","maybeBackoff","err","isRetryableTransactionError","Promise","reject","promise","result","error","code","resetToMax","backoffAndWait","readOptions","Array","isArray","length","isPlainObject","pop","i","validateDocumentReference","validateReadOptions","optional","map","fieldPath","FieldPath","fromArgument","arg","validateOptional","isObject","invalidArgumentMessage","validateFieldPath","message","match"],"sources":["C:/Users/lauri/node_modules/@google-cloud/firestore/build/src/transaction.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseGetAllArguments = exports.Transaction = void 0;\nconst backoff_1 = require(\"./backoff\");\nconst index_1 = require(\"./index\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst document_reader_1 = require(\"./document-reader\");\n/*!\n * Error message for transactional reads that were executed after performing\n * writes.\n */\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\nconst READ_ONLY_WRITE_ERROR_MSG = 'Firestore read-only transactions cannot execute writes.';\n/**\n * A reference to a transaction.\n *\n * The Transaction object passed to a transaction's updateFunction provides\n * the methods to read and write data within the transaction context. See\n * [runTransaction()]{@link Firestore#runTransaction}.\n *\n * @class Transaction\n */\nclass Transaction {\n    /**\n     * @private\n     *\n     * @param firestore The Firestore Database client.\n     * @param requestTag A unique client-assigned identifier for the scope of\n     * this transaction.\n     * @param transactionOptions The user-defined options for this transaction.\n     */\n    constructor(firestore, requestTag, transactionOptions) {\n        this._readOnly = false;\n        this._maxAttempts = index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;\n        this._firestore = firestore;\n        this._writeBatch = firestore.batch();\n        this._requestTag = requestTag;\n        this._backoff = new backoff_1.ExponentialBackoff();\n        if (transactionOptions) {\n            if (transactionOptions.readOnly) {\n                this._readOnly = true;\n                this._maxAttempts = 1;\n                this._readTime = transactionOptions.readTime;\n            }\n            else {\n                this._maxAttempts =\n                    transactionOptions.maxAttempts || index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;\n            }\n        }\n    }\n    /**\n     * Retrieve a document or a query result from the database. Holds a\n     * pessimistic lock on all returned documents.\n     *\n     * @param {DocumentReference|Query} refOrQuery The document or query to\n     * return.\n     * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\n     * QuerySnapshot for the returned documents.\n     *\n     * @example\n     * ```\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     * ```\n     */\n    get(refOrQuery) {\n        if (!this._writeBatch.isEmpty) {\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n        }\n        if (refOrQuery instanceof reference_1.DocumentReference) {\n            const documentReader = new document_reader_1.DocumentReader(this._firestore, [refOrQuery]);\n            documentReader.transactionId = this._transactionId;\n            documentReader.readTime = this._readTime;\n            return documentReader.get(this._requestTag).then(([res]) => res);\n        }\n        if (refOrQuery instanceof reference_1.Query) {\n            return refOrQuery._get(this._transactionId || this._readTime);\n        }\n        if (refOrQuery instanceof reference_1.AggregateQuery) {\n            return refOrQuery._get(this._transactionId || this._readTime);\n        }\n        throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference, Query, or AggregateQuery.');\n    }\n    /**\n     * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\n     * all returned documents.\n     *\n     * The first argument is required and must be of type `DocumentReference`\n     * followed by any additional `DocumentReference` documents. If used, the\n     * optional `ReadOptions` must be the last argument.\n     *\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\n     * `DocumentReferences` to receive, followed by an optional field mask.\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n     * contains an array with the resulting document snapshots.\n     *\n     * @example\n     * ```\n     * let firstDoc = firestore.doc('col/doc1');\n     * let secondDoc = firestore.doc('col/doc2');\n     * let resultDoc = firestore.doc('col/doc3');\n     *\n     * firestore.runTransaction(transaction => {\n     *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\n     *     transaction.set(resultDoc, {\n     *       sum: docs[0].get('count') + docs[1].get('count')\n     *     });\n     *   });\n     * });\n     * ```\n     */\n    getAll(...documentRefsOrReadOptions) {\n        if (!this._writeBatch.isEmpty) {\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n        }\n        (0, validate_1.validateMinNumberOfArguments)('Transaction.getAll', documentRefsOrReadOptions, 1);\n        const { documents, fieldMask } = parseGetAllArguments(documentRefsOrReadOptions);\n        const documentReader = new document_reader_1.DocumentReader(this._firestore, documents);\n        documentReader.fieldMask = fieldMask || undefined;\n        documentReader.transactionId = this._transactionId;\n        documentReader.readTime = this._readTime;\n        return documentReader.get(this._requestTag);\n    }\n    /**\n     * Create the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The operation will\n     * fail the transaction if a document exists at the specified location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {DocumentData} data The object data to serialize as the document.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * ```\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (!doc.exists) {\n     *       transaction.create(documentRef, { foo: 'bar' });\n     *     }\n     *   });\n     * });\n     * ```\n     */\n    create(documentRef, data) {\n        if (this._readOnly) {\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n        }\n        this._writeBatch.create(documentRef, data);\n        return this;\n    }\n    /**\n     * Writes to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * does not exist yet, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into the\n     * existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T|Partial<T>} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched. If your input sets any field to an empty map, all nested fields\n     * are overwritten.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched. If your input sets any field to\n     * an empty map, all nested fields are overwritten.\n     * @throws {Error} If the provided input is not a valid Firestore document.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * ```\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.set(documentRef, { foo: 'bar' });\n     *   return Promise.resolve();\n     * });\n     * ```\n     */\n    set(documentRef, data, options) {\n        if (this._readOnly) {\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n        }\n        if (options) {\n            this._writeBatch.set(documentRef, data, options);\n        }\n        else {\n            this._writeBatch.set(documentRef, data);\n        }\n        return this;\n    }\n    /**\n     * Updates fields in the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The update will\n     * fail if applied to a document that does not exist.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to to enforce on this update.\n     * @throws {Error} If the provided input is not valid Firestore data.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * ```\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     * ```\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        if (this._readOnly) {\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n        }\n        // eslint-disable-next-line prefer-rest-params\n        (0, validate_1.validateMinNumberOfArguments)('Transaction.update', arguments, 2);\n        this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided [DocumentReference]\n     * {@link DocumentReference}.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the transaction if the\n     * document doesn't exist or was last updated at a different time.\n     * @param {boolean=} precondition.exists If set, enforces that the target\n     * document must or must not exist.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * ```\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.delete(documentRef);\n     *   return Promise.resolve();\n     * });\n     * ```\n     */\n    delete(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    documentRef, precondition) {\n        if (this._readTime) {\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n        }\n        this._writeBatch.delete(documentRef, precondition);\n        return this;\n    }\n    /**\n     * Starts a transaction and obtains the transaction id from the server.\n     *\n     * @private\n     * @internal\n     */\n    async begin() {\n        const request = {\n            database: this._firestore.formattedName,\n        };\n        if (this._readOnly) {\n            request.options = {\n                readOnly: {},\n            };\n        }\n        else if (this._transactionId) {\n            request.options = {\n                readWrite: {\n                    retryTransaction: this._transactionId,\n                },\n            };\n        }\n        const resp = await this._firestore.request('beginTransaction', request, this._requestTag);\n        this._transactionId = resp.transaction;\n    }\n    /**\n     * Commits all queued-up changes in this transaction and releases all locks.\n     *\n     * @private\n     * @internal\n     */\n    async commit() {\n        if (this._readTime) {\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n        }\n        await this._writeBatch._commit({\n            transactionId: this._transactionId,\n            requestTag: this._requestTag,\n        });\n    }\n    /**\n     * Releases all locks and rolls back this transaction.\n     *\n     * @private\n     * @internal\n     */\n    async rollback() {\n        if (!this._transactionId) {\n            return;\n        }\n        const request = {\n            database: this._firestore.formattedName,\n            transaction: this._transactionId,\n        };\n        try {\n            await this._firestore.request('rollback', request, this._requestTag);\n        }\n        catch (reason) {\n            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Best effort to rollback failed with error:', reason);\n        }\n    }\n    /**\n     * Executes `updateFunction()` and commits the transaction with retry.\n     *\n     * @private\n     * @internal\n     * @param updateFunction The user function to execute within the transaction\n     * context.\n     */\n    async runTransaction(updateFunction) {\n        if (this._maxAttempts === 1) {\n            return this.runTransactionOnce(updateFunction);\n        }\n        let lastError = undefined;\n        for (let attempt = 0; attempt < this._maxAttempts; ++attempt) {\n            try {\n                if (lastError) {\n                    (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);\n                }\n                this._writeBatch._reset();\n                await this.maybeBackoff(lastError);\n                return await this.runTransactionOnce(updateFunction);\n            }\n            catch (err) {\n                lastError = err;\n                if (!this._transactionId || !isRetryableTransactionError(err)) {\n                    break;\n                }\n            }\n        }\n        (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\n        return Promise.reject(lastError);\n    }\n    /**\n     * Make single attempt to execute `updateFunction()` and commit the\n     * transaction. Will rollback upon error.\n     *\n     * @private\n     * @internal\n     * @param updateFunction The user function to execute within the transaction\n     * context.\n     */\n    async runTransactionOnce(updateFunction) {\n        if (!this._readTime) {\n            await this.begin();\n        }\n        try {\n            const promise = updateFunction(this);\n            if (!(promise instanceof Promise)) {\n                throw new Error('You must return a Promise in your transaction()-callback.');\n            }\n            const result = await promise;\n            if (!this._readTime) {\n                await this.commit();\n            }\n            return result;\n        }\n        catch (err) {\n            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);\n            await this.rollback();\n            return Promise.reject(err);\n        }\n    }\n    /**\n     * Delays further operations based on the provided error.\n     *\n     * @private\n     * @internal\n     * @return A Promise that resolves after the delay expired.\n     */\n    async maybeBackoff(error) {\n        if ((error === null || error === void 0 ? void 0 : error.code) === 8 /* StatusCode.RESOURCE_EXHAUSTED */) {\n            this._backoff.resetToMax();\n        }\n        await this._backoff.backoffAndWait();\n    }\n}\nexports.Transaction = Transaction;\n/**\n * Parses the arguments for the `getAll()` call supported by both the Firestore\n * and Transaction class.\n *\n * @private\n * @internal\n * @param documentRefsOrReadOptions An array of document references followed by\n * an optional ReadOptions object.\n */\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n    let documents;\n    let readOptions = undefined;\n    if (Array.isArray(documentRefsOrReadOptions[0])) {\n        throw new Error('getAll() no longer accepts an array as its first argument. ' +\n            'Please unpack your array and call getAll() with individual arguments.');\n    }\n    if (documentRefsOrReadOptions.length > 0 &&\n        (0, util_1.isPlainObject)(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n        readOptions = documentRefsOrReadOptions.pop();\n        documents = documentRefsOrReadOptions;\n    }\n    else {\n        documents = documentRefsOrReadOptions;\n    }\n    for (let i = 0; i < documents.length; ++i) {\n        (0, reference_1.validateDocumentReference)(i, documents[i]);\n    }\n    validateReadOptions('options', readOptions, { optional: true });\n    const fieldMask = readOptions && readOptions.fieldMask\n        ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath))\n        : null;\n    return { fieldMask, documents };\n}\nexports.parseGetAllArguments = parseGetAllArguments;\n/**\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\n * is an array of strings or field paths.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the ReadOptions can be omitted.\n */\nfunction validateReadOptions(arg, value, options) {\n    if (!(0, validate_1.validateOptional)(value, options)) {\n        if (!(0, util_1.isObject)(value)) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} Input is not an object.'`);\n        }\n        const options = value;\n        if (options.fieldMask !== undefined) {\n            if (!Array.isArray(options.fieldMask)) {\n                throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} \"fieldMask\" is not an array.`);\n            }\n            for (let i = 0; i < options.fieldMask.length; ++i) {\n                try {\n                    (0, path_1.validateFieldPath)(i, options.fieldMask[i]);\n                }\n                catch (err) {\n                    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\n                }\n            }\n        }\n    }\n}\nfunction isRetryableTransactionError(error) {\n    if (error.code !== undefined) {\n        // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\n        switch (error.code) {\n            case 10 /* StatusCode.ABORTED */:\n            case 1 /* StatusCode.CANCELLED */:\n            case 2 /* StatusCode.UNKNOWN */:\n            case 4 /* StatusCode.DEADLINE_EXCEEDED */:\n            case 13 /* StatusCode.INTERNAL */:\n            case 14 /* StatusCode.UNAVAILABLE */:\n            case 16 /* StatusCode.UNAUTHENTICATED */:\n            case 8 /* StatusCode.RESOURCE_EXHAUSTED */:\n                return true;\n            case 3 /* StatusCode.INVALID_ARGUMENT */:\n                // The Firestore backend uses \"INVALID_ARGUMENT\" for transactions\n                // IDs that have expired. While INVALID_ARGUMENT is generally not\n                // retryable, we retry this specific case.\n                return !!error.message.match(/transaction has expired/);\n            default:\n                return false;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=transaction.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}